---
layout: posts
title:  "leetcode 23 Merge k Sorted Lists [우선순위 큐]"
categories: algorithm
---

## heapq를 이용하여 우선순위 큐 풀기

### <span style="background-color: #00CC99">leetcode 23. Merge k Sorted Lists</span>  

heapq 모듈을 이해하고 우선순위 큐 구현하기  

* **우선순위 큐** : 우선순위가 높은 원소가 먼저 출력되는 추상적 자료형  
  우선순위 값을 먼저 출력해주면 되므로 직접 우선순위가 높은 값을 찾아서 출력하거나 제거해주어도 된다. 하지만 input값이 많아질수록 이 과정은 비효율적이다.  
  => 힙을 이용하여 효율적으로 구현하자!  

#### <span style="background-color: #FFCC33">heapq - 힙 큐 알고리즘</span>
힙: 최솟값과 최댓값을 빠르게 찾아주는 완전 이진트리

> **트리** : 그래프의 형태 중 하나로 계층적인 구조로 되어있는 자료구조이다. 트리의 간선들은 모두 방향성을 갖고 정점에서 다른 정점으로 이동할 수 있는 경로는 1개이다. 사이클을 갖지 않는다.  
> 트리구조에서 다른 정점이 가르키지 않는 가장 위에 있는 정점을 루트노드(root node)라고 한다. 아래 그림에서는 정점2가 루트노드이다. 또, 루트노드로부터의 거리를 깊이라고 한다.  
> 정점A가 다른 정점B를 가리킬 때 A를 부모노드(parent node), B를 자식노드(child node)라고 한다. 예를들어, 아래 그림에서 정점2는 정점7의 부모노드이고 정점7은 정점2의 자식노드이다.  
> 가르키고 있는 정점이 없는 정점을 리프노드(leaf node)라 한다. 아래 그림에서는 정점 2, 5, 11, 4가 이에 해당한다.  
> **이진트리** : 각 정점이 자식노드를 최대 2개까지만 갖는 트리  

<p>
  <img src="https://user-images.githubusercontent.com/88446465/165231814-0f650e88-f969-4b2f-a4f6-6a95f7ba5eb1.png" width="400" height="350" /><br/>
  <em>출처: https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EA%B5%AC%EC%A1%B0 </em>
</p>

```
import heap
```

1. 힙의 종류
  * 최대힙 (Max Heap)  
    부모 노드가 자식 노드보다 크거나 같은 값을 갖는 이진트리
  * 최소힙 (Min Heap) - default  
    부모 노드가 자식 노드보다 작거나 같은 값을 갖는 이진트리


2. 힙 작동방식
  힙은 최소힙이 기본이다. 힙은 완전 이진 트리의 특성을 유지해야 해서 입력된 자료는 마지막 레벨의 가장 오른쪽 자리에 추가된다.  
  예를들어, 아래와 같이 정점6이 추가 되면 부모 노드(정점8)과 값을 비교하여 자리를 바꿔준다. 해당 과정을 부모 노드가 더 작은 값이 될 때까지 반복한다.
    <img width="300" alt="스크린샷 2022-04-26 오후 3 27 30" src="https://user-images.githubusercontent.com/88446465/165235749-f07d9830-243d-476a-a27d-7c23f45968ce.png">  
  위의 경우 정점6이 자신보다 더 작은 부모 노드를 만나려면 자리를 한번만 바꿔주면 되므로 아래와 같이 바뀌게 된다.  
    <img width="300" alt="스크린샷 2022-04-26 오후 3 27 35" src="https://user-images.githubusercontent.com/88446465/165236156-3820e282-b321-44b5-aec5-29652031a733.png">  
  이렇게 





**최종코드**

```
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        root = result = ListNode(None)
        heap = []
        
        for i in range(len(lists)):
            if lists[i]:
                heapq.heappush(heap, (lists[i].val, i, lists[i]))
        
        while heap:
            node = heapq.heappop(heap)
            idx = node[1]
            result.next = node[2]
            
            result = result.next
            if result.next:
                heapq.heappush(heap, (result.next.val, idx, result.next))
                
        return root.next
```

참고 풀이: 파이썬 알고리즘 인터뷰




문제: https://leetcode.com/problems/merge-k-sorted-lists/


